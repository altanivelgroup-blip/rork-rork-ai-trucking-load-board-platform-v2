import createContextHook from '@nkzw/create-context-hook';
import { useCallback, useState } from 'react';
import { Platform } from 'react-native';
import { useStripe } from '@stripe/stripe-react-native';
import { trpc } from '@/lib/trpc';
import { useAuth } from './useAuth';

export interface PaymentTransaction {
  id: string;
  amount: number;
  type: 'delivery_fee' | 'membership' | 'wallet_topup';
  status: 'pending' | 'completed' | 'failed';
  date: Date;
  description?: string;
  metadata?: Record<string, any>;
}

export interface PaymentState {
  isProcessing: boolean;
  transactions: PaymentTransaction[];
  processDeliveryFee: (loadId: string, deliveryAmount: number) => Promise<void>;
  processMembershipUpgrade: (membershipType: 'basic' | 'premium') => Promise<void>;
  processWalletTopUp: (amount: number) => Promise<void>;
  getPaymentHistory: () => Promise<void>;
}

export const [PaymentProvider, usePayments] = createContextHook<PaymentState>(() => {
  const { user } = useAuth();
  const { initPaymentSheet, presentPaymentSheet } = useStripe();
  const [isProcessing, setIsProcessing] = useState<boolean>(false);
  const [transactions, setTransactions] = useState<PaymentTransaction[]>([]);

  const createDeliveryFeeIntentMutation = trpc.payments.createDeliveryFeeIntent.useMutation();
  const createMembershipIntentMutation = trpc.payments.createMembershipIntent.useMutation();
  const createWalletTopUpIntentMutation = trpc.payments.createWalletTopUpIntent.useMutation();
  const confirmPaymentMutation = trpc.payments.confirmPayment.useMutation();
  const paymentHistoryQuery = trpc.payments.getPaymentHistory.useQuery(
    { userId: user?.id || '' },
    { enabled: !!user?.id }
  );

  const processPayment = useCallback(async (
    clientSecret: string,
    paymentIntentId: string,
    type: 'delivery_fee' | 'membership' | 'wallet_topup'
  ) => {
    if (!user) throw new Error('User not authenticated');

    try {
      setIsProcessing(true);
      console.log('[Payments] Processing payment for type:', type);

      if (Platform.OS === 'web') {
        // For web, we'll simulate payment success for testing
        console.log('[Payments] Web payment simulation - Payment processed successfully');
        
        const result = await confirmPaymentMutation.mutateAsync({
          paymentIntentId,
          userId: user.id,
        });

        if (result.success) {
          console.log('[Payments] Payment processed - Fee applied successfully');
          await getPaymentHistory();
        }
      } else {
        // For mobile, use Stripe payment sheet
        const { error: initError } = await initPaymentSheet({
          merchantDisplayName: 'LoadRush',
          paymentIntentClientSecret: clientSecret,
          defaultBillingDetails: {
            name: user.name || user.email,
            email: user.email,
          },
        });

        if (initError) {
          throw new Error(`Payment sheet initialization failed: ${initError.message}`);
        }

        const { error: presentError } = await presentPaymentSheet();

        if (presentError) {
          if (presentError.code === 'Canceled') {
            console.log('[Payments] Payment canceled by user');
            return;
          }
          throw new Error(`Payment failed: ${presentError.message}`);
        }

        // Confirm payment on backend
        const result = await confirmPaymentMutation.mutateAsync({
          paymentIntentId,
          userId: user.id,
        });

        if (result.success) {
          console.log('[Payments] Payment processed - Fee applied successfully');
          await getPaymentHistory();
        }
      }
    } catch (error) {
      console.error('[Payments] Payment processing error:', error);
      throw error;
    } finally {
      setIsProcessing(false);
    }
  }, [user, initPaymentSheet, presentPaymentSheet, confirmPaymentMutation]);

  const processDeliveryFee = useCallback(async (loadId: string, deliveryAmount: number) => {
    if (!user) throw new Error('User not authenticated');

    try {
      console.log('[Payments] Processing delivery fee for load:', loadId);
      
      const result = await createDeliveryFeeIntentMutation.mutateAsync({
        loadId,
        deliveryAmount,
        userId: user.id,
      });

      await processPayment(result.clientSecret!, result.paymentIntentId, 'delivery_fee');
    } catch (error) {
      console.error('[Payments] Delivery fee processing error:', error);
      throw error;
    }
  }, [user, createDeliveryFeeIntentMutation, processPayment]);

  const processMembershipUpgrade = useCallback(async (membershipType: 'basic' | 'premium') => {
    if (!user) throw new Error('User not authenticated');

    try {
      console.log('[Payments] Processing membership upgrade:', membershipType);
      
      const result = await createMembershipIntentMutation.mutateAsync({
        membershipType,
        userId: user.id,
      });

      await processPayment(result.clientSecret!, result.paymentIntentId, 'membership');
    } catch (error) {
      console.error('[Payments] Membership upgrade processing error:', error);
      throw error;
    }
  }, [user, createMembershipIntentMutation, processPayment]);

  const processWalletTopUp = useCallback(async (amount: number) => {
    if (!user) throw new Error('User not authenticated');

    try {
      console.log('[Payments] Processing wallet top-up:', amount);
      
      const result = await createWalletTopUpIntentMutation.mutateAsync({
        amount,
        userId: user.id,
      });

      await processPayment(result.clientSecret!, result.paymentIntentId, 'wallet_topup');
    } catch (error) {
      console.error('[Payments] Wallet top-up processing error:', error);
      throw error;
    }
  }, [user, createWalletTopUpIntentMutation, processPayment]);

  const getPaymentHistory = useCallback(async () => {
    try {
      await paymentHistoryQuery.refetch();
      if (paymentHistoryQuery.data) {
        setTransactions(paymentHistoryQuery.data.map(payment => ({
          id: payment.id,
          amount: payment.amount,
          type: payment.type as 'delivery_fee' | 'membership' | 'wallet_topup',
          status: payment.status as 'pending' | 'completed' | 'failed',
          date: payment.date,
          description: payment.description,
          metadata: payment.metadata,
        })));
      }
    } catch (error) {
      console.error('[Payments] Error fetching payment history:', error);
    }
  }, [paymentHistoryQuery]);

  return {
    isProcessing,
    transactions,
    processDeliveryFee,
    processMembershipUpgrade,
    processWalletTopUp,
    getPaymentHistory,
  };
});