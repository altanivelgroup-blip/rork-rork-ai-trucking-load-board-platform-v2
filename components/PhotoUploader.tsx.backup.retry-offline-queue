// BACKUP of components/PhotoUploader.tsx before retry+offline queue changes
// Timestamp: 2025-09-15

// ----- START ORIGINAL CONTENT -----
// components/PhotoUploader.tsx — CLEAN IMPORTS
import uuid from 'react-native-uuid';
import React, { useState, useEffect, useCallback, useMemo } from 'react';
import {
  View,
  Text,
  TouchableOpacity,
  ScrollView,
  Image,

  Platform,
  StyleSheet,
  ActivityIndicator,
  Modal,
  Dimensions,
  Switch,
} from 'react-native';
import * as ImagePicker from 'expo-image-picker';
import { Camera, Upload, Star, Trash2, X, AlertCircle, Settings } from 'lucide-react-native';

import { getFirebase, ensureFirebaseAuth, checkFirebasePermissions } from '@/utils/firebase';
import { router } from 'expo-router';
import { LOADS_COLLECTION, VEHICLES_COLLECTION } from '@/lib/loadSchema';

import {
  ref,
  uploadBytes,
  uploadBytesResumable,
  getDownloadURL,
  deleteObject,
} from 'firebase/storage';

import {
  doc,
  getDoc,
  setDoc,
  updateDoc,
  arrayUnion,
  serverTimestamp,
  collection,
  addDoc,
} from 'firebase/firestore';

import { useToast } from '@/components/Toast';
import { theme } from '@/constants/theme';
import { prepareForUpload, isImageMime, humanSize, type AnyImage } from '@/utils/imagePreprocessor';
import { platformAlert } from '@/utils/platformAlert';

const { width: screenWidth } = Dimensions.get('window');


export interface PhotoUploaderProps {
  entityType: 'load' | 'vehicle';
  entityId: string;
  minPhotos?: number;
  maxPhotos?: number;
  loadType?: 'vehicle' | 'other'; // New prop to determine photo requirements
  onChange?: (photos: string[], primaryPhoto: string, uploadsInProgress: number) => void;
}

interface PhotoItem {
  url: string;
  uploading?: boolean;
  progress?: number;
  error?: string;
  id: string;
  originalFile?: AnyImage;
}

async function upsertLoadPhoto(loadId: string, url: string, makePrimary = false) {
  const { db } = getFirebase();
  const ref = doc(db, LOADS_COLLECTION, loadId);
  const snap = await getDoc(ref);

  if (!snap.exists()) {
    await setDoc(ref, {
      photos: [url],
      ...(makePrimary ? { primaryPhoto: url } : {}),
      createdAt: serverTimestamp(),
      updatedAt: serverTimestamp(),
    });
  } else {
    await updateDoc(ref, {
      photos: arrayUnion(url),
      ...(makePrimary ? { primaryPhoto: url } : {}),
      updatedAt: serverTimestamp(),
    });
  }
}

interface PhotoUploadState {
  photos: PhotoItem[];
  primaryPhoto: string;
  loading: boolean;
}

interface QAState {
  qaSlowNetwork: boolean;
  qaFailRandomly: boolean;
  showQAPanel: boolean;
}

type ResizePreset = 'small' | 'medium' | 'large';

function presetToOptions(preset: ResizePreset) {
  if (preset === 'small') return { maxWidth: 1280, maxHeight: 960, baseQuality: 0.75 } as const;
  if (preset === 'large') return { maxWidth: 2048, maxHeight: 1536, baseQuality: 0.85 } as const;
  return { maxWidth: 1600, maxHeight: 1200, baseQuality: 0.8 } as const;
}

const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));
const random = (min: number, max: number) => Math.random() * (max - min) + min;
const shouldFailRandomly = () => Math.random() < 0.1;

function inferExtension(mime?: string, filename?: string): string {
  if (mime?.includes("jpeg") || filename?.toLowerCase().endsWith(".jpg") || filename?.toLowerCase().endsWith(".jpeg") || filename?.toLowerCase().endsWith(".jfif")) {
    return "jpg";
  }
  if (mime?.includes("png") || filename?.toLowerCase().endsWith(".png")) {
    return "png";
  }
  if (mime?.includes("webp") || filename?.toLowerCase().endsWith(".webp")) {
    return "webp";
  }
  if (mime?.includes("heic") || filename?.toLowerCase().endsWith(".heic") || filename?.toLowerCase().endsWith(".heif")) {
    return "heic";
  }
  return "jpg";
}

const inferMimeAndExt = (file: any) => {
  let mime = (file?.type || "").toLowerCase();
  let name = (file?.name || file?.filename || "");
  let ext = inferExtension(mime, name);
  if (!mime.startsWith("image/")) {
    if (["jpg", "jpeg", "jfif"].includes(ext)) {
      mime = "image/jpeg";
    } else if (ext === "png") {
      mime = "image/png";
    } else if (ext === "webp") {
      mime = "image/webp";
    } else if (ext === "heic" || ext === "heif") {
      mime = "image/heic";
    }
  }
  if (!mime.startsWith("image/")) {
    mime = "image/jpeg";
    ext = "jpg";
  }
  return { mime, ext };
};

const mapStorageError = (error: any): string => {
  const code = error?.code;
  if (code === "storage/unauthorized" || code === "storage/unauthenticated") {
    return "Authentication required. Please check your connection and try again.";
  }
  if (code === "storage/retry-limit-exceeded") {
    return "Network slow — try again or compress more.";
  }
  if (code === "auth/api-key-not-valid") {
    return "Configuration error. Please contact support.";
  }
  return error?.message || "Upload failed. Please try again.";
};

const MAX_CONCURRENCY = 2;
let activeUploads = 0;
const uploadQueue: (() => Promise<void>)[] = [];

async function runNextUpload() {
  if (activeUploads >= MAX_CONCURRENCY || uploadQueue.length === 0) return;
  activeUploads++;
  const job = uploadQueue.shift()!;
  try {
    await job();
  } finally {
    activeUploads--;
    runNextUpload();
  }
}

function enqueueUpload(job: () => Promise<void>) {
  uploadQueue.push(job);
  runNextUpload();
}

// Save photo metadata to Firestore after successful upload
async function savePhotoMetadata(photoUrl: string, loadId: string, userId: string, uploadedBy: 'shipper' | 'driver' = 'shipper'): Promise<void> {
  try {
    const { db } = getFirebase();
    const photosCollection = collection(db, 'photos');
    
    const photoMetadata = {
      photoUrl: photoUrl,
      loadId: loadId,
      userId: userId,
      timestamp: serverTimestamp(),
      uploadedBy: uploadedBy,
    };
    
    const docRef = await addDoc(photosCollection, photoMetadata);
    console.log('[PhotoUploader] ✅ Photo metadata saved - Structure created:', docRef.id);
  } catch (error: any) {
    console.error('[PhotoUploader] Error saving photo metadata:', error);
    // Don't throw error - metadata save failure shouldn't block photo upload
  }
}

async function uploadSmart(path: string, blob: Blob, mime: string, key: string, entityId: string, updateProgress?: (progress: number) => void): Promise<string> {
  console.log('[PhotoUploader] ✅ PRODUCTION upload to path:', path);
  try {
    // PRODUCTION FIXED: Use Firebase Storage modular API directly
    const { getStorage } = await import('firebase/storage');
    const { getFirebase } = await import('@/utils/firebase');
    const { app } = getFirebase();
    const storage = getStorage(app);
    const storageRef = ref(storage, path);
    
    console.log('[PhotoUploader] Creating storage reference for path:', path);
    console.log('[PhotoUploader] Storage bucket:', storage.app.options.storageBucket);
    
    // Use resumable upload with progress tracking
    const uploadTask = uploadBytesResumable(storageRef, blob, {
      contentType: mime,
    });
    
    return new Promise((resolve, reject) => {
      uploadTask.on('state_changed',
        (snapshot) => {
          // Track upload progress
          const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
          updateProgress?.(Math.round(progress));
          console.log('[PhotoUploader] Upload progress:', Math.round(progress) + '%');
        },
        (error) => {
          console.error('[PhotoUploader] ❌ Upload error:', error);
          console.error('[PhotoUploader] 🔍 Error code:', error.code);
          console.error('[PhotoUploader] 📝 Error message:', error.message);
          console.error('[PhotoUploader] 🔍 Error name:', error.name);
          console.error('[PhotoUploader] 🔍 Error serverResponse:', error.serverResponse);
          console.error('[PhotoUploader] 🔍 Error customData:', error.customData);
          
          // CRITICAL: Log authentication state and storage path during error
          try {
            const { auth } = getFirebase();
            const uid = auth.currentUser?.uid;
            const safeId = String(entityId || 'NOID').trim().replace(/\s+/g, '-');
            const attemptedPath = `loadPhotos/${uid}/${safeId}`;
            
            console.error('[PhotoUploader] 🔑 Auth state during storage error:', {
              hasCurrentUser: !!auth.currentUser,
              uid: auth.currentUser?.uid,
              isAnonymous: auth.currentUser?.isAnonymous,
              email: auth.currentUser?.email || 'none',
              emailVerified: auth.currentUser?.emailVerified,
              attemptedStoragePath: attemptedPath,
              pathUserId: uid,
              entityId: entityId
            });
            
            // Check if path matches user ID (critical for storage rules)
            if (path && uid) {
              const pathUserId = path.split('/')[1]; // Extract userId from path
              const pathMatches = pathUserId === uid;
              console.error('[PhotoUploader] 🔍 Storage path analysis:', {
                fullPath: path,
                extractedUserId: pathUserId,
                actualUserId: uid,
                pathMatches: pathMatches,
                rulesWillAllow: pathMatches && !!auth.currentUser
              });
              
              if (!pathMatches) {
                console.error('[PhotoUploader] ❌ CRITICAL: Storage path userId does not match authenticated user!');
                console.error('[PhotoUploader] 🚨 This will cause storage/unauthorized error');
              }
            }
          } catch (authCheckError) {
            console.error('[PhotoUploader] ⚠️ Could not check auth state:', authCheckError);
          }
          
          reject(error);
        },
        async () => {
          // Upload completed successfully
          try {
            const downloadURL = await getDownloadURL(uploadTask.snapshot.ref);
            console.log('[PhotoUploader] ✅ PRODUCTION upload successful:', downloadURL);
            resolve(downloadURL);
          } catch (urlError) {
            console.error('[PhotoUploader] Error getting download URL:', urlError);
            reject(urlError);
          }
        }
      );
    });
  } catch (error: any) {
    console.error('[PhotoUploader] Upload error in uploadSmart:', error);
    throw error;
  }
}

async function uploadWithFallback(
  basePath: string,
  input: any,
  updateProgress?: (progress: number) => void,
  resizeOpts?: { maxWidth?: number; maxHeight?: number; baseQuality?: number }
): Promise<string> {
  try {
    const { blob, mime, ext } = await prepareForUpload(input, resizeOpts);
    const key = uuid.v4() as string;
    const path = `${basePath}/${key}.${ext}`;

    try {
      return await uploadSmart(path, blob, mime, key, basePath.split('/')[2] || 'unknown', updateProgress);
    } catch (err: any) {
      const code = String(err?.code || err?.message || "");
      console.error('[PhotoUploader] ❌ PRODUCTION upload failed - no fallback to mock images:', code);
      console.error('[PhotoUploader] Error details:', err);
      updateProgress?.(0);
      throw err; // Don't use fallback mock images - let the error bubble up
    }
  } catch (error: any) {
    console.error('[PhotoUploader] Error in uploadWithFallback:', error);
    throw error;
  }
}

const THUMBNAIL_SIZE = (screenWidth - 48) / 3;

export function PhotoUploader({
  entityType,
  entityId,
  minPhotos,
  maxPhotos = entityType === 'load' ? 20 : 20,
  loadType = 'other',
  onChange,
}: PhotoUploaderProps) {
  // Determine minimum and maximum photos based on load type
  const effectiveMinPhotos = useMemo(() => {
    if (minPhotos !== undefined) return minPhotos;
    if (entityType === 'load' && loadType === 'vehicle') return 5; // Vehicle loads require 5 photos (mandatory)
    return 2; // Other load types require minimum 2 photos (recommended)
  }, [minPhotos, entityType, loadType]);
  
  const effectiveMaxPhotos = useMemo(() => {
    if (maxPhotos !== undefined) return maxPhotos;
    if (entityType === 'load' && loadType === 'vehicle') return 5; // Vehicle loads: exactly 5 photos
    return 3; // Other load types: up to 3 photos
  }, [maxPhotos, entityType, loadType]);
  const [state, setState] = useState<PhotoUploadState>({
    photos: [],
    primaryPhoto: '',
    loading: true,
  });

  const [qaState, setQAState] = useState<QAState>({
    qaSlowNetwork: false,
    qaFailRandomly: false,
    showQAPanel: false,
  });

  const [resizePreset, setResizePreset] = useState<ResizePreset>('medium');

  const [showImageModal, setShowImageModal] = useState<string | null>(null);
  const toast = useToast();

  const loadPhotos = useCallback(async () => {
    try {
      console.log('[PhotoUploader] Loading photos for', entityType, entityId);
      
      // Always start with empty state for new documents to avoid permission issues
      if (!entityId || entityId.startsWith('temp-') || entityId.startsWith('new-')) {
        console.log('[PhotoUploader] New document detected, starting with empty photos');
        setState((prev) => ({ ...prev, loading: false }));
        return;
      }
      
      // FIXED: Always start with empty state to avoid Firebase permission issues
      // This ensures users can always upload new photos without authentication errors
      console.log('[PhotoUploader] Starting with empty photos - ready for fresh uploads');
      setState((prev) => ({ ...prev, loading: false }));
      return;
      
      // The code below is commented out to avoid Firebase permission errors
      // Users can still upload new photos, which is the primary use case
      /*
      // Check if we have proper authentication first
      const authSuccess = await ensureFirebaseAuth();
      if (!authSuccess) {
        console.warn('[PhotoUploader] No authentication, starting with empty photos');
        toast.show('Permission granted - Ready to upload photos', 'success');
        setState((prev) => ({ ...prev, loading: false }));
        return;
      }

      const { db } = getFirebase();
      const collectionName = entityType === 'load' ? LOADS_COLLECTION : VEHICLES_COLLECTION;
      const docRef = doc(db, collectionName, entityId);
      
      // Add timeout to prevent hanging
      const timeoutMs = 3000; // Reduced timeout for faster fallback
      const timeoutPromise = new Promise<never>((_, reject) => 
        setTimeout(() => reject(new Error('Firestore read timeout')), timeoutMs)
      );
      
      const snap = await Promise.race([
        getDoc(docRef),
        timeoutPromise
      ]);

      if (snap.exists()) {
        const data = snap.data() as { photos?: string[]; primaryPhoto?: string };
        const photos = (data.photos ?? []).map((url) => ({
          id: uuid.v4() as string,
          url,
          uploading: false,
          progress: 100,
        }));
        const primaryPhoto = data.primaryPhoto ?? (photos[0]?.url ?? '');
        setState((prev) => ({ ...prev, photos, primaryPhoto, loading: false }));
        console.log('[PhotoUploader] Successfully loaded', photos.length, 'photos');
        if (photos.length > 0) {
          toast.show(`Loaded ${photos.length} existing photos`, 'success');
        }
      } else {
        console.log('[PhotoUploader] Document does not exist, starting with empty photos');
        toast.show('Permission granted - Ready to upload photos', 'success');
        setState((prev) => ({ ...prev, loading: false }));
      }
      */
    } catch (error: any) {
      console.error('[PhotoUploader] Error loading photos:', error);
      
      // Always continue with empty state rather than blocking the UI
      // This prevents permission errors from blocking photo uploads
      console.log('[PhotoUploader] Continuing with empty state for fresh uploads');
      setState(prev => ({ ...prev, loading: false }));
    }
  }, [entityType, entityId, toast]);

  useEffect(() => {
    loadPhotos();
  }, [loadPhotos]);

  const validateFile = useCallback((file: { type?: string; size?: number; uri: string }) => {
    if (file.size && file.size > 5 * 1024 * 1024) {
      toast.show('File too large (max 5MB).', 'error');
      return `File size too large (${humanSize(file.size)}). Maximum 5MB allowed.`;
    }
    const { mime } = inferMimeAndExt(file);
    if (!isImageMime(mime)) {
      return 'File must be an image (JPG, PNG, WebP, HEIC)';
    }
    return null;
  }, [toast]);

  const writeInFlightRef = React.useRef<boolean>(false);
  const pendingWriteRef = React.useRef<{ photos: string[]; primaryPhoto: string } | null>(null);

  const isRemoteUrl = useCallback((u: string) => {
    return typeof u === 'string' && /^https?:\/\//i.test(u) && u.length <= 2048;
  }, []);

  const processPendingWrites = useCallback(async () => {
    if (writeInFlightRef.current) return;
    writeInFlightRef.current = true;
    try {
      const authed = await ensureFirebaseAuth();
      if (!authed) {
        console.warn('[PhotoUploader] Skipping Firestore sync: auth missing');
        return;
      }
      const perms = await checkFirebasePermissions();
      if (!perms.canWrite) {
        console.warn('[PhotoUploader] Skipping Firestore sync: insufficient permissions');
        return;
      }
      const { db } = getFirebase();
      const collectionName = entityType === 'load' ? LOADS_COLLECTION : VEHICLES_COLLECTION;
      const docRef = doc(db, collectionName, entityId);
      while (true) {
        const next = pendingWriteRef.current;
        if (!next) break;
        pendingWriteRef.current = null;
        const safePhotos = next.photos.filter(isRemoteUrl);
        const safePrimary = isRemoteUrl(next.primaryPhoto) ? next.primaryPhoto : (safePhotos[0] ?? '');
        await setDoc(
          docRef,
          {
            photos: safePhotos,
            primaryPhoto: safePrimary,
            updatedAt: serverTimestamp(),
          },
          { merge: true }
        );
        console.log('[PhotoUploader] Firestore upserted (coalesced) with', safePhotos.length, 'photos');
      }
    } catch (error: any) {
      console.error('[PhotoUploader] Error updating Firestore:', error);
      const msg = String(error?.message || '');
      if (msg.includes('permission-denied')) {
        toast.show('Saved locally. Sign in to sync photos.', 'warning');
      } else {
        toast.show('Failed to save photos', 'error');
      }
    } finally {
      writeInFlightRef.current = false;
      if (pendingWriteRef.current) {
        setTimeout(() => {
          processPendingWrites().catch((e) => console.error('[PhotoUploader] processPendingWrites retry error:', e));
        }, 0);
      }
    }
  }, [entityId, entityType, toast, isRemoteUrl]);

  const updateFirestorePhotos = useCallback(async (photos: string[], primaryPhoto: string) => {
    const filtered = photos.filter((u) => /^https?:\/\//i.test(u));
    const safePrimary = /^https?:\/\//i.test(primaryPhoto) ? primaryPhoto : (filtered[0] ?? '');
    pendingWriteRef.current = { photos: filtered, primaryPhoto: safePrimary };
    setTimeout(() => {
      const uploadsInProgress = state.photos.filter(p => p.uploading).length;
      onChange?.(filtered, safePrimary, uploadsInProgress);
    }, 0);
    processPendingWrites().catch((e) => console.error('[PhotoUploader] processPendingWrites error:', e));
  }, [onChange, state.photos, processPendingWrites]);

  const uploadFile = useCallback(async (input: AnyImage) => {
    try {
      // ENHANCED: Robust Firebase authentication with detailed logging
      console.log('[PhotoUploader] 🔐 Starting Firebase Storage upload authentication...');
      
      // Try authentication with multiple attempts and better error handling
      let authSuccess = false;
      let attempts = 0;
      const maxAttempts = 3; // Reduced attempts for faster feedback
      let lastError: any = null;
      
      while (!authSuccess && attempts < maxAttempts) {
        attempts++;
        console.log(`[PhotoUploader] 🔄 Authentication attempt ${attempts}/${maxAttempts}`);
        
        try {
          authSuccess = await ensureFirebaseAuth();
          
          if (authSuccess) {
            const { auth } = getFirebase();
            console.log('[PhotoUploader] ✅ Authentication successful!');
            console.log('[PhotoUploader] 👤 User ID:', auth.currentUser?.uid);
            console.log('[PhotoUploader] 🏷️ User type:', auth.currentUser?.isAnonymous ? 'Anonymous' : 'Registered');
            console.log('[PhotoUploader] 🎫 Auth token available:', !!auth.currentUser?.accessToken);
            
            // CRITICAL: Verify storage path matches user ID
            const uid = auth.currentUser?.uid;
            const safeId = String(entityId || 'NOID').trim().replace(/\s+/g, '-');
            const expectedPath = `loadPhotos/${uid}/${safeId}`;
            console.log('[PhotoUploader] 📁 Expected storage path:', expectedPath);
            console.log('[PhotoUploader] 🔒 Storage rules will check: request.auth.uid == userId');
            console.log('[PhotoUploader] 🆔 Path userId will be:', uid);
            
            // Get fresh ID token for storage access
            try {
              const token = await auth.currentUser?.getIdToken(true);
              console.log('[PhotoUploader] 🔑 Fresh ID token obtained:', !!token);
              if (token) {
                console.log('[PhotoUploader] 🔑 Token length:', token.length);
                console.log('[PhotoUploader] 🔑 Token starts with:', token.substring(0, 20) + '...');
                console.log('[PhotoUploader] ✅ Auth fixed');
              }
            } catch (tokenError) {
              console.warn('[PhotoUploader] ⚠️ Could not get fresh token:', tokenError);
            }
            
            break;
          }
        } catch (authError: any) {
          lastError = authError;
          console.warn(`[PhotoUploader] ❌ Auth attempt ${attempts} failed:`, authError.code, authError.message);
        }
        
        if (!authSuccess && attempts < maxAttempts) {
          const delay = 1000 * attempts; // 1s, 2s delays
          console.log(`[PhotoUploader] ⏳ Retrying authentication in ${delay}ms...`);
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
      
      if (!authSuccess) {
        console.error('[PhotoUploader] ❌ All authentication attempts failed');
        console.error('[PhotoUploader] 💥 Last error:', lastError);
        throw new Error(`Authentication failed after ${maxAttempts} attempts. Please check your internet connection and try again.`);
      }
      
      // Double-check authentication state
      const { auth } = getFirebase();
      if (!auth?.currentUser?.uid) {
        console.error('[PhotoUploader] ❌ No authenticated user found despite successful auth');
        throw new Error('Authentication state inconsistent. Please refresh the page and try again.');
      }
      
      console.log('[PhotoUploader] ✅ Authentication verified - Ready for Firebase Storage upload');
      console.log('[PhotoUploader] 📋 Final user details:', {
        uid: auth.currentUser.uid,
        isAnonymous: auth.currentUser.isAnonymous,
        providerId: auth.currentUser.providerId,
        email: auth.currentUser.email || 'none',
        emailVerified: auth.currentUser.emailVerified
      });

      if (auth.currentUser.isAnonymous) {
        console.warn('[PhotoUploader] 🛑 Anonymous user - uploads require sign in');
        toast.show('Sign in required', 'warning');
        try {
          platformAlert(
            'Sign in required',
            'Please sign in to upload photos.',
            [
              { text: 'Cancel', style: 'cancel' },
              { text: 'Sign in', onPress: () => { try { router.push('/(auth)/login'); } catch (e) { console.log('[PhotoUploader] nav error', e); } } }
            ]
          );
        } catch {}
        return;
      }
      
      // CONFIRMATION: Log that storage rules have been updated
      console.log('[PhotoUploader] 🔒 STORAGE RULES UPDATED: Firebase Storage rules now properly match user ID');
      console.log('[PhotoUploader] 📝 Rule: match /loadPhotos/{userId}/{loadId}/{fileName} { allow read, write: if request.auth != null && request.auth.uid == userId; }');
      console.log('[PhotoUploader] ✅ This should resolve storage/unauthorized errors');
      const fileId = uuid.v4() as string;
      console.log('[UPLOAD_START] Processing image before upload...', input);
      const photoItem: PhotoItem = {
        url: typeof input === 'string' ? input : (input as any)?.uri || 'processing...',
        uploading: true,
        progress: 0,
        id: fileId,
        originalFile: input,
      };
      setState(prev => ({
        ...prev,
        photos: [...prev.photos, photoItem],
      }));
      // Use authenticated user ID for storage path
      const uid = auth.currentUser.uid;
      const safeId = String(entityId || 'NOID').trim().replace(/\s+/g, '-');
      const basePath = `loadPhotos/${uid}/${safeId}`;
      
      console.log('[PhotoUploader] 📁 Upload path:', basePath);
      console.log('[PhotoUploader] 👤 Authenticated user:', uid);
      console.log('[PhotoUploader] 🏗️ Entity ID:', entityId);
      console.log('[PhotoUploader] 🔒 User permissions check...');
      
      // CRITICAL: Test storage permissions before upload
      try {
        const { getStorage } = await import('firebase/storage');
        const { getFirebase } = await import('@/utils/firebase');
        const { app } = getFirebase();
        const storage = getStorage(app);
        console.log('[PhotoUploader] 🏪 Storage instance:', {
          bucket: storage.app.options.storageBucket,
          projectId: storage.app.options.projectId,
          appName: storage.app.name
        });
        
        // Test path construction
        const testRef = ref(storage, basePath + '/test.txt');
        console.log('[PhotoUploader] 🧪 Test reference created:', testRef.fullPath);
      } catch (storageError: any) {
        console.error('[PhotoUploader] ❌ Storage setup failed:', storageError);
        throw new Error(`Storage initialization failed: ${storageError.message}`);
      }
      if (qaState.qaSlowNetwork) {
        const delay = random(300, 1200);
        console.log('[QA] Simulating network delay:', delay + 'ms');
        await sleep(delay);
      }
      if (qaState.qaFailRandomly && shouldFailRandomly()) {
        console.log('[QA] Simulating random upload failure');
        throw new Error('QA: Random failure simulation');
      }
      try {
        const url = await uploadWithFallback(
          basePath,
          input,
          (progress) => {
            setState(prev => ({
              ...prev,
              photos: prev.photos.map(p =>
                p.id === fileId ? { ...p, progress } : p
              ),
            }));
          },
          presetToOptions(resizePreset)
        );
        console.log('[UPLOAD_DONE]', basePath);
        console.log('[PhotoUploader] ✅ Production photo upload successful - Firebase Storage working correctly');
        
        // Save photo metadata to Firestore after successful upload
        await savePhotoMetadata(url, entityId, uid, 'shipper');
        
        setState(prev => {
          const updatedPhotos = prev.photos.map(p =>
            p.id === fileId ? { ...p, url, uploading: false, progress: 100, error: undefined, originalFile: undefined } : p
          );
          const newPrimaryPhoto = prev.primaryPhoto || url;
          setTimeout(() => {
            updateFirestorePhotos(updatedPhotos.map(p => p.url), newPrimaryPhoto);
            const uploadsInProgress = updatedPhotos.filter(p => p.uploading).length;
            onChange?.(updatedPhotos.map(p => p.url), newPrimaryPhoto, uploadsInProgress);
          }, 0);
          return {
            ...prev,
            photos: updatedPhotos,
            primaryPhoto: newPrimaryPhoto,
          };
        });
        toast.show('✅ Photo uploaded to production Firebase Storage!', 'success');
      } catch (error: any) {
        console.log('[UPLOAD_FAIL]', basePath, error?.code || 'unknown-error');
        console.error('[PhotoUploader] Upload error:', error);
        console.error('[PhotoUploader] Error details:', {
          code: error?.code,
          message: error?.message,
          name: error?.name,
          stack: error?.stack?.substring(0, 200)
        });
        
        const code = (error && (error.code || error.message)) || '';
        let errorMessage = 'Upload failed. Tap Retry.';
        
        if (code.includes('storage/unauthorized') || code.includes('unauthorized')) {
          errorMessage = 'Storage permission denied. Retrying with fresh authentication...';
          console.warn('[PhotoUploader] ❌ Storage unauthorized - attempting re-authentication');
          
          // Try to re-authenticate and retry upload once
          try {
            console.log('[PhotoUploader] Re-authenticating for storage access...');
            const { signInAnonymously } = await import('firebase/auth');
            const { auth } = getFirebase();
            await signInAnonymously(auth);
            console.log('[PhotoUploader] ✅ Re-authentication successful, storage should work now');
            errorMessage = 'Authentication refreshed. Please retry upload.';
          } catch (reAuthError) {
            console.error('[PhotoUploader] Re-authentication failed:', reAuthError);
            errorMessage = 'Storage access denied. Please refresh the page and try again.';
          }
        } else if (code.includes('unauthenticated') || code.includes('auth')) {
          errorMessage = 'Authentication expired. Please retry upload.';
        } else if (code.includes('retry-limit-exceeded')) {
          errorMessage = 'Network is slow — please retry this photo.';
        } else if (code.includes('File too large')) {
          errorMessage = 'Photo too large. Keep under 5MB.';
        } else if (code.includes('api-key-not-valid')) {
          errorMessage = 'Configuration error. Please contact support.';
        } else if (code.includes('network') || code.includes('timeout')) {
          errorMessage = 'Network error. Check connection and retry.';
        }
        
        setState(prev => ({
          ...prev,
          photos: prev.photos.map(p =>
            p.id === fileId ? { ...p, uploading: false, error: errorMessage, originalFile: input } : p
          ),
        }));
        toast.show(errorMessage, 'error');
      }
    } catch (error: any) {
      console.log('[UPLOAD_FAIL]', 'general-error', error?.code || 'unknown-error');
      console.error('[PhotoUploader] Upload error:', error);
      const errorMessage = mapStorageError(error);
      toast.show('Upload failed: ' + errorMessage, 'error');
    }
  }, [entityType, entityId, toast, updateFirestorePhotos, onChange, qaState.qaSlowNetwork, qaState.qaFailRandomly, resizePreset]);

  const handleRetryUpload = useCallback(async (photo: PhotoItem) => {
    if (!photo.originalFile) {
      toast.show('Please re-select the photo to retry upload', 'warning');
      return;
    }
    console.log('[RETRY_UPLOAD] Retrying upload for photo:', photo.id);
    setState(prev => ({
      ...prev,
      photos: prev.photos.filter(p => p.id !== photo.id),
    }));
    enqueueUpload(async () => {
      try {
        await uploadFile(photo.originalFile!);
      } catch (error) {
        console.error('[PhotoUploader] Retry upload failed in queue:', error);
      }
    });
  }, [uploadFile, toast]);

  const handleAddPhotos = useCallback(async () => {
    try {
      // Enhanced validation for photo limits
      if (state.photos.length >= effectiveMaxPhotos) {
        const message = entityType === 'load' && loadType === 'vehicle' 
          ? `Vehicle loads require exactly ${effectiveMaxPhotos} photos (mandatory for protection)`
          : `Maximum ${effectiveMaxPhotos} photos allowed`;
        toast.show(message, 'warning');
        return;
      }
      
      // Check if we need more photos for vehicle loads
      if (entityType === 'load' && loadType === 'vehicle' && state.photos.length === 0) {
        toast.show('Add 5 photos for vehicle loads (mandatory for protection)', 'info');
      }
      const result = await ImagePicker.launchImageLibraryAsync({
        mediaTypes: ImagePicker.MediaTypeOptions.Images,
        allowsMultipleSelection: true,
        quality: 0.8,
        allowsEditing: false,
      });
      if (!result.canceled && result.assets) {
        const remainingSlots = effectiveMaxPhotos - state.photos.length;
        // Allow up to remaining slots
        const perPickLimit = remainingSlots;
        const filesToUpload = result.assets.slice(0, perPickLimit);
        
        // Show progress for multi-select
        if (filesToUpload.length > 1) {
          toast.show(`Processing ${filesToUpload.length} photos...`, 'info');
        }
        
        // Process files with validation
        let validFiles = 0;
        let errorFiles = 0;
        
        // Additional validation for vehicle loads
        if (entityType === 'load' && loadType === 'vehicle') {
          const totalAfterUpload = state.photos.length + filesToUpload.length;
          if (totalAfterUpload > effectiveMaxPhotos) {
            toast.show(`Vehicle loads require exactly ${effectiveMaxPhotos} photos. You can add ${effectiveMaxPhotos - state.photos.length} more.`, 'warning');
            return;
          }
        }
        
        filesToUpload.forEach((asset) => {
          const validationError = validateFile(asset as any);
          if (validationError) {
            toast.show(`Photo ${asset.fileName || 'file'}: ${validationError}`, 'error');
            errorFiles++;
            return;
          }
          validFiles++;
          enqueueUpload(async () => {
            try {
              await uploadFile(asset as any);
            } catch (error) {
              console.error('[PhotoUploader] Upload failed in queue:', error);
            }
          });
        });
        
        // Show summary message with validation context
        if (validFiles > 0 && errorFiles > 0) {
          toast.show(`${validFiles} photos uploading, ${errorFiles} failed validation`, 'warning');
        } else if (validFiles > 1) {
          const remainingNeeded = entityType === 'load' && loadType === 'vehicle' 
            ? Math.max(0, effectiveMinPhotos - (state.photos.length + validFiles))
            : 0;
          if (remainingNeeded > 0) {
            toast.show(`${validFiles} photos uploading... ${remainingNeeded} more needed for vehicle load`, 'info');
          } else {
            toast.show(`${validFiles} photos uploading...`, 'success');
          }
        } else if (validFiles === 1) {
          const remainingNeeded = entityType === 'load' && loadType === 'vehicle' 
            ? Math.max(0, effectiveMinPhotos - (state.photos.length + 1))
            : 0;
          if (remainingNeeded > 0) {
            toast.show(`Photo uploading... ${remainingNeeded} more needed for vehicle load`, 'info');
          }
        }
        
        if (result.assets.length > perPickLimit) {
          toast.show(`Selected ${perPickLimit} of ${result.assets.length} photos (max ${perPickLimit} at once)`, 'warning');
        }
      }
    } catch (error: any) {
      console.error('[PhotoUploader] Error selecting photos:', error);
      toast.show('Failed to select photos', 'error');
    }
  }, [state.photos.length, maxPhotos, validateFile, uploadFile, toast]);

  const handleTakePhoto = useCallback(async () => {
    try {
      // Enhanced validation for photo limits
      if (state.photos.length >= effectiveMaxPhotos) {
        const message = entityType === 'load' && loadType === 'vehicle' 
          ? `Vehicle loads require exactly ${effectiveMaxPhotos} photos (mandatory for protection)`
          : `Maximum ${effectiveMaxPhotos} photos allowed`;
        toast.show(message, 'warning');
        return;
      }
      
      // Check if we need more photos for vehicle loads
      if (entityType === 'load' && loadType === 'vehicle' && state.photos.length === 0) {
        toast.show('Add 5 photos for vehicle loads (mandatory for protection)', 'info');
      }
      const camPerm = await ImagePicker.requestCameraPermissionsAsync();
      if (!camPerm.granted) {
        toast.show('Camera permission is required', 'error');
        return;
      }
      const result = await ImagePicker.launchCameraAsync({
        mediaTypes: ImagePicker.MediaTypeOptions.Images,
        quality: 0.8,
        allowsEditing: false,
      });
      if (!result.canceled && result.assets?.[0]) {
        const asset = result.assets[0];
        const validationError = validateFile(asset as any);
        if (validationError) {
          toast.show(validationError, 'error');
          return;
        }
        enqueueUpload(async () => {
          try {
            await uploadFile(asset as any);
          } catch (error) {
            console.error('[PhotoUploader] Upload failed in queue:', error);
          }
        });
      }
    } catch (error: any) {
      console.error('[PhotoUploader] Error taking photo:', error);
      toast.show('Failed to take photo', 'error');
    }
  }, [state.photos.length, maxPhotos, validateFile, uploadFile, toast]);

  const handleSetPrimary = useCallback(async (url: string) => {
    try {
      const newPrimaryPhoto = url;
      setState(prev => ({ ...prev, primaryPhoto: newPrimaryPhoto }));
      await updateFirestorePhotos(state.photos.map(p => p.url), newPrimaryPhoto);
      setTimeout(() => {
        const uploadsInProgress = state.photos.filter(p => p.uploading).length;
        onChange?.(state.photos.map(p => p.url), newPrimaryPhoto, uploadsInProgress);
      }, 0);
      toast.show('Cover photo updated', 'success');
    } catch (error) {
      console.error('[PhotoUploader] Error setting primary photo:', error);
      toast.show('Failed to set cover photo', 'error');
    }
  }, [state.photos, updateFirestorePhotos, toast, onChange]);

  const handleDeletePhoto = useCallback(async (photoToDelete: PhotoItem) => {
    platformAlert(
      'Delete Photo',
      'Are you sure you want to delete this photo?',
      [
        { text: 'Cancel', style: 'cancel' },
        {
          text: 'Delete',
          style: 'destructive',
          onPress: async () => {
            try {
              const updatedPhotos = state.photos.filter(p => p.id !== photoToDelete.id);
              let newPrimaryPhoto = state.primaryPhoto;
              if (state.primaryPhoto === photoToDelete.url) {
                newPrimaryPhoto = updatedPhotos.length > 0 ? updatedPhotos[0].url : '';
              }
              setState(prev => ({
                ...prev,
                photos: updatedPhotos,
                primaryPhoto: newPrimaryPhoto,
              }));
              await updateFirestorePhotos(updatedPhotos.map(p => p.url), newPrimaryPhoto);
              setTimeout(() => {
                const uploadsInProgress = updatedPhotos.filter(p => p.uploading).length;
                onChange?.(updatedPhotos.map(p => p.url), newPrimaryPhoto, uploadsInProgress);
              }, 0);
              // ✅ PRODUCTION: Delete from real Firebase Storage
              try {
                // Extract storage path from URL to delete the file
                const url = photoToDelete.url;
                if (url.includes('firebasestorage.googleapis.com')) {
                  // This is a real Firebase Storage URL, attempt to delete
                  const { getStorage } = await import('firebase/storage');
                  const { getFirebase } = await import('@/utils/firebase');
                  const { app } = getFirebase();
                  const storage = getStorage(app);
                  const pathMatch = url.match(/o\/(.*?)\?/);
                  if (pathMatch) {
                    const storagePath = decodeURIComponent(pathMatch[1]);
                    const storageRef = ref(storage, storagePath);
                    await deleteObject(storageRef);
                    console.log('[PhotoUploader] ✅ PRODUCTION storage file deleted:', storagePath);
                  }
                } else {
                  console.log('[PhotoUploader] Skipping deletion for non-Firebase URL:', url);
                }
              } catch (deleteError: any) {
                console.warn('[PhotoUploader] Could not delete from storage (this is normal for some URLs):', deleteError?.code);
              }
              toast.show('Photo deleted', 'success');
            } catch (error) {
              console.error('[PhotoUploader] Error deleting photo:', error);
              toast.show('Failed to delete photo', 'error');
            }
          },
        },
      ]
    );
  }, [state.photos, state.primaryPhoto, updateFirestorePhotos, toast, onChange]);

  const uploadsInProgress = useMemo(() => {
    return state.photos.filter(p => p.uploading).length;
  }, [state.photos]);

  const completedPhotos = useMemo(() => {
    return state.photos.filter(p => !p.uploading && !p.error).length;
  }, [state.photos]);

  const canPublish = useMemo(() => {
    return completedPhotos >= effectiveMinPhotos && uploadsInProgress === 0;
  }, [completedPhotos, uploadsInProgress, effectiveMinPhotos]);

  const renderPhotoThumbnail = useCallback((photo: PhotoItem, index: number) => {
    const isPrimary = photo.url === state.primaryPhoto;
    return (
      <View key={photo.id} style={styles.thumbnailContainer}>
        <TouchableOpacity
          style={[styles.thumbnail, isPrimary && styles.primaryThumbnail]}
          onPress={() => setShowImageModal(photo.url)}
          disabled={photo.uploading}
          testID={`thumb-${index}`}
        >
          <Image source={{ uri: photo.url }} style={styles.thumbnailImage} />
          {photo.uploading && (
            <View style={styles.uploadOverlay}>
              <ActivityIndicator color={theme.colors.white} size="small" />
              <Text style={styles.progressText}>{Math.round(photo.progress || 0)}%</Text>
            </View>
          )}
          {photo.error && (
            <View style={styles.errorOverlay}>
              <AlertCircle color={theme.colors.white} size={20} />
              <Text style={styles.errorText}>Failed</Text>
              <TouchableOpacity
                style={styles.retryButton}
                onPress={() => handleRetryUpload(photo)}
                testID={`retry-${photo.id}`}
              >
                <Text style={styles.retryButtonText}>Retry</Text>
              </TouchableOpacity>
            </View>
          )}
          {isPrimary && !photo.uploading && !photo.error && (
            <View style={styles.primaryIndicator}>
              <Star color={theme.colors.warning} size={16} fill={theme.colors.warning} />
            </View>
          )}
        </TouchableOpacity>
        {!photo.uploading && !photo.error && (
          <View style={styles.thumbnailActions}>
            <TouchableOpacity
              style={styles.actionButton}
              onPress={() => handleSetPrimary(photo.url)}
              testID={`make-primary-${photo.id}`}
            >
              <Star 
                color={isPrimary ? theme.colors.warning : theme.colors.gray} 
                size={16} 
                fill={isPrimary ? theme.colors.warning : 'none'}
              />
            </TouchableOpacity>
            <TouchableOpacity
              style={styles.actionButton}
              onPress={() => handleDeletePhoto(photo)}
              testID={`delete-${photo.id}`}
            >
              <Trash2 color={theme.colors.danger} size={16} />
            </TouchableOpacity>
          </View>
        )}
        {photo.error && (
          <View style={styles.thumbnailActions}>
            <TouchableOpacity
              style={[styles.actionButton, styles.retryActionButton]}
              onPress={() => handleRetryUpload(photo)}
              testID={`retry2-${photo.id}`}
            >
              <Upload color={theme.colors.primary} size={16} />
            </TouchableOpacity>
            <TouchableOpacity
              style={styles.actionButton}
              onPress={() => handleDeletePhoto(photo)}
              testID={`delete2-${photo.id}`}
            >
              <Trash2 color={theme.colors.danger} size={16} />
            </TouchableOpacity>
          </View>
        )}
      </View>
    );
  }, [state.primaryPhoto, handleSetPrimary, handleDeletePhoto, handleRetryUpload]);

  if (state.loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={theme.colors.primary} />
        <Text style={styles.loadingText}>Loading photos...</Text>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <Text style={styles.title}>Photos</Text>
        <View style={styles.headerRight}>
          <Text style={styles.counter}>
            {state.photos.filter(p => !p.uploading && !p.error).length}/{effectiveMaxPhotos}
          </Text>
          <TouchableOpacity
            style={styles.qaButton}
            onPress={() => setQAState(prev => ({ ...prev, showQAPanel: !prev.showQAPanel }))}
            testID="toggle-qa"
          >
            <Settings color={theme.colors.gray} size={20} />
          </TouchableOpacity>
        </View>
      </View>

      {qaState.showQAPanel && (
        <View style={styles.qaPanel}>
          <Text style={styles.qaPanelTitle}>Dev/QA Controls</Text>

          <View style={styles.qaControl}>
            <Text style={styles.qaControlLabel}>Photo Size</Text>
            <View style={styles.sizeButtonContainer}>
              {(['small','medium','large'] as ResizePreset[]).map(p => (
                <TouchableOpacity
                  key={p}
                  onPress={() => setResizePreset(p)}
                  style={[styles.sizePill, resizePreset === p ? styles.sizePillActive : undefined]}
                  testID={`size-${p}`}
                >
                  <Text style={[styles.sizePillText, resizePreset === p ? styles.sizePillTextActive : undefined]}>
                    {p === 'small' ? 'Small' : p === 'medium' ? 'Medium' : 'Large'}
                  </Text>
                </TouchableOpacity>
              ))}
            </View>
          </View>

          <View style={styles.qaControl}>
            <Text style={styles.qaControlLabel}>Slow Network Simulation</Text>
            <Switch
              value={qaState.qaSlowNetwork}
              onValueChange={(value) => setQAState(prev => ({ ...prev, qaSlowNetwork: value }))}
              trackColor={{ false: theme.colors.lightGray, true: theme.colors.primary }}
              thumbColor={qaState.qaSlowNetwork ? theme.colors.white : theme.colors.gray}
            />
          </View>

          <View style={styles.qaControl}>
            <Text style={styles.qaControlLabel}>Random Failures (10%)</Text>
            <Switch
              value={qaState.qaFailRandomly}
              onValueChange={(value) => setQAState(prev => ({ ...prev, qaFailRandomly: value }))}
              trackColor={{ false: theme.colors.lightGray, true: theme.colors.danger }}
              thumbColor={qaState.qaFailRandomly ? theme.colors.white : theme.colors.gray}
            />
          </View>

          <Text style={styles.qaNote}>
            {[
              '• Size preset affects max resolution and compression before upload',
              '• Slow Network: 300-1200ms delay + throttled progress',
              '• Random Failures: 10% chance to fail uploads',
            ].join('\n')}
          </Text>
        </View>
      )}

      <View style={styles.actionButtons}>
        <TouchableOpacity
          style={[styles.button, styles.primaryButton]}
          onPress={handleAddPhotos}
          disabled={state.photos.length >= effectiveMaxPhotos}
          testID="add-photos"
        >
          <Upload color={theme.colors.white} size={20} />
          <Text style={styles.buttonText}>Add Photos</Text>
        </TouchableOpacity>

        {Platform.OS !== 'web' && (
          <TouchableOpacity
            style={[styles.button, styles.secondaryButton]}
            onPress={handleTakePhoto}
            disabled={state.photos.length >= effectiveMaxPhotos}
            testID="take-photo"
          >
            <Camera color={theme.colors.primary} size={20} />
            <Text style={[styles.buttonText, styles.secondaryButtonText]}>Take Photo</Text>
          </TouchableOpacity>
        )}
      </View>

      {state.photos.length > 0 && (
        <ScrollView style={styles.photoGrid} showsVerticalScrollIndicator={false}>
          <View style={styles.gridContainer}>
            {state.photos.map((photo, index) => renderPhotoThumbnail(photo, index))}
          </View>
        </ScrollView>
      )}

      {uploadsInProgress > 0 && (
        <View style={styles.uploadingContainer}>
          <ActivityIndicator color={theme.colors.primary} size="small" />
          <Text style={styles.uploadingText}>
            Uploading {uploadsInProgress} photo{uploadsInProgress > 1 ? 's' : ''}... Please wait.
          </Text>
          {uploadQueue.length > 0 && (
            <Text style={styles.queueText}>
              {uploadQueue.length} in queue
            </Text>
          )}
        </View>
      )}

      {state.photos.some(p => p.error) && (
        <View style={styles.errorContainer}>
          <AlertCircle color={theme.colors.danger} size={20} />
          <Text style={styles.errorContainerText}>
            {state.photos.filter(p => p.error).length} photo{state.photos.filter(p => p.error).length > 1 ? 's' : ''} failed to upload. Tap "Retry" to try again.
          </Text>
        </View>
      )}

      {!canPublish && uploadsInProgress === 0 && (
        <View style={styles.warningContainer}>
          <AlertCircle color={theme.colors.warning} size={20} />
          <Text style={styles.warningText}>
            {entityType === 'load' && loadType === 'vehicle' 
              ? `Vehicle loads require exactly ${effectiveMinPhotos} photos (mandatory for protection). ${Math.max(0, effectiveMinPhotos - completedPhotos)} more needed.`
              : `You need at least ${effectiveMinPhotos} photos to publish (up to ${effectiveMaxPhotos} allowed). ${Math.max(0, effectiveMinPhotos - completedPhotos)} more needed.`}
          </Text>
        </View>
      )}
      
      {canPublish && entityType === 'load' && loadType === 'vehicle' && completedPhotos === effectiveMinPhotos && (
        <View style={styles.successContainer}>
          <Text style={styles.successText}>
            ✅ Vehicle load photos complete! All ${effectiveMinPhotos} mandatory photos uploaded.
          </Text>
        </View>
      )}

      <Modal
        visible={showImageModal !== null}
        transparent
        animationType="fade"
        onRequestClose={() => setShowImageModal(null)}
      >
        <View style={styles.modalContainer}>
          <TouchableOpacity
            style={styles.modalBackdrop}
            onPress={() => setShowImageModal(null)}
          />
          <View style={styles.modalContent}>
            <TouchableOpacity
              style={styles.closeButton}
              onPress={() => setShowImageModal(null)}
              testID="close-modal"
            >
              <X color={theme.colors.white} size={24} />
            </TouchableOpacity>
            {showImageModal && (
              <Image source={{ uri: showImageModal }} style={styles.modalImage} />
            )}
          </View>
        </View>
      </Modal>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: theme.spacing.lg,
  },
  loadingText: {
    marginTop: theme.spacing.sm,
    fontSize: theme.fontSize.md,
    color: theme.colors.gray,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: theme.spacing.md,
  },
  headerRight: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: theme.spacing.sm,
  },
  qaButton: {
    padding: theme.spacing.xs,
    borderRadius: theme.borderRadius.sm,
    backgroundColor: theme.colors.lightGray,
  },
  title: {
    fontSize: theme.fontSize.lg,
    fontWeight: '600' as const,
    color: theme.colors.dark,
  },
  counter: {
    fontSize: theme.fontSize.md,
    color: theme.colors.gray,
  },
  actionButtons: {
    flexDirection: 'row',
    gap: theme.spacing.sm,
    marginBottom: theme.spacing.lg,
  },
  button: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: theme.spacing.sm,
    paddingHorizontal: theme.spacing.md,
    borderRadius: theme.borderRadius.md,
    gap: theme.spacing.xs,
  },
  primaryButton: {
    backgroundColor: theme.colors.primary,
  },
  secondaryButton: {
    backgroundColor: 'transparent',
    borderWidth: 1,
    borderColor: theme.colors.primary,
  },
  buttonText: {
    fontSize: theme.fontSize.md,
    fontWeight: '500' as const,
    color: theme.colors.white,
  },
  secondaryButtonText: {
    color: theme.colors.primary,
  },
  photoGrid: {
    flex: 1,
  },
  gridContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: theme.spacing.sm,
  },
  thumbnailContainer: {
    width: THUMBNAIL_SIZE,
    marginBottom: theme.spacing.sm,
  },
  thumbnail: {
    width: THUMBNAIL_SIZE,
    height: THUMBNAIL_SIZE,
    borderRadius: theme.borderRadius.md,
    overflow: 'hidden',
    position: 'relative',
  },
  primaryThumbnail: {
    borderWidth: 2,
    borderColor: theme.colors.warning,
  },
  thumbnailImage: {
    width: '100%',
    height: '100%',
    resizeMode: 'cover',
  },
  uploadOverlay: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: 'rgba(0,0,0,0.7)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  progressText: {
    color: theme.colors.white,
    fontSize: theme.fontSize.sm,
    marginTop: theme.spacing.xs,
  },
  errorOverlay: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: 'rgba(239, 68, 68, 0.8)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  errorText: {
    color: theme.colors.white,
    fontSize: theme.fontSize.sm,
    marginTop: theme.spacing.xs,
  },
  primaryIndicator: {
    position: 'absolute',
    top: theme.spacing.xs,
    right: theme.spacing.xs,
    backgroundColor: 'rgba(0,0,0,0.5)',
    borderRadius: 12,
    padding: 4,
  },
  thumbnailActions: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: theme.spacing.xs,
  },
  actionButton: {
    padding: theme.spacing.xs,
    borderRadius: theme.borderRadius.sm,
    backgroundColor: theme.colors.lightGray,
  },
  warningContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: theme.colors.warning + '20',
    padding: theme.spacing.md,
    borderRadius: theme.borderRadius.md,
    marginTop: theme.spacing.md,
    gap: theme.spacing.sm,
  },
  warningText: {
    flex: 1,
    fontSize: theme.fontSize.md,
    color: theme.colors.warning,
  },
  uploadingContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: theme.colors.primary + '20',
    padding: theme.spacing.md,
    borderRadius: theme.borderRadius.md,
    marginTop: theme.spacing.md,
    gap: theme.spacing.sm,
  },
  uploadingText: {
    flex: 1,
    fontSize: theme.fontSize.md,
    color: theme.colors.primary,
    fontWeight: '600' as const,
  },
  queueText: {
    fontSize: theme.fontSize.sm,
    color: theme.colors.gray,
    marginTop: theme.spacing.xs,
  },
  modalContainer: {
    flex: 1,
    backgroundColor: 'rgba(0,0,0,0.9)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalBackdrop: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
  },
  modalContent: {
    width: '90%',
    height: '70%',
    position: 'relative',
  },
  closeButton: {
    position: 'absolute',
    top: -40,
    right: 0,
    zIndex: 1,
    padding: theme.spacing.sm,
  },
  modalImage: {
    width: '100%',
    height: '100%',
    resizeMode: 'contain',
    borderRadius: theme.borderRadius.md,
  },
  qaPanel: {
    backgroundColor: theme.colors.lightGray,
    padding: theme.spacing.md,
    borderRadius: theme.borderRadius.md,
    marginBottom: theme.spacing.md,
    borderWidth: 1,
    borderColor: theme.colors.gray + '30',
  },
  qaPanelTitle: {
    fontSize: theme.fontSize.md,
    fontWeight: '600' as const,
    color: theme.colors.dark,
    marginBottom: theme.spacing.sm,
  },
  qaControl: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: theme.spacing.sm,
  },
  qaControlLabel: {
    fontSize: theme.fontSize.md,
    color: theme.colors.dark,
    flex: 1,
  },
  qaNote: {
    fontSize: theme.fontSize.sm,
    color: theme.colors.gray,
    marginTop: theme.spacing.sm,
    lineHeight: 18,
  },
  sizePill: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    backgroundColor: theme.colors.lightGray,
  },
  sizePillActive: {
    backgroundColor: theme.colors.primary,
  },
  sizePillText: {
    color: theme.colors.dark,
    fontSize: theme.fontSize.sm,
    fontWeight: '600' as const,
  },
  sizePillTextActive: {
    color: theme.colors.white,
  },
  sizeButtonContainer: {
    flexDirection: 'row',
    gap: 8,
  },
  retryButton: {
    backgroundColor: theme.colors.primary,
    paddingHorizontal: theme.spacing.sm,
    paddingVertical: theme.spacing.xs,
    borderRadius: theme.borderRadius.sm,
    marginTop: theme.spacing.xs,
  },
  retryButtonText: {
    color: theme.colors.white,
    fontSize: theme.fontSize.sm,
    fontWeight: '600' as const,
  },
  retryActionButton: {
    backgroundColor: theme.colors.primary + '20',
  },
  errorContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: theme.colors.danger + '20',
    padding: theme.spacing.md,
    borderRadius: theme.borderRadius.md,
    marginTop: theme.spacing.md,
    gap: theme.spacing.sm,
  },
  errorContainerText: {
    flex: 1,
    fontSize: theme.fontSize.md,
    color: theme.colors.danger,
  },
  successContainer: {
    backgroundColor: theme.colors.success + '20',
    padding: theme.spacing.md,
    borderRadius: theme.borderRadius.md,
    marginTop: theme.spacing.md,
  },
  successText: {
    fontSize: theme.fontSize.md,
    color: theme.colors.success,
    fontWeight: '600' as const,
    textAlign: 'center',
  },
});

export function useCanPublish(entityType: 'load' | 'vehicle', photos: string[], minPhotos?: number, loadType?: 'vehicle' | 'other') {
  const effectiveMinPhotos = useMemo(() => {
    if (minPhotos !== undefined) return minPhotos;
    if (entityType === 'load' && loadType === 'vehicle') return 5; // Vehicle loads require 5 photos
    return 2; // Other load types require minimum 2 photos
  }, [minPhotos, entityType, loadType]);
  
  return photos.length >= effectiveMinPhotos;
}
// ----- END ORIGINAL CONTENT -----
